#pragma kernel RayTracing
#pragma multi_compile_local __ _WHITE_STYLE

#include "Struct.compute"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
TextureCube<float4> Skybox;
// 采样器名称必须和纹理名称完全一致再在前面加上sampler
SamplerState samplerSkybox;
StructuredBuffer<Sphere> SphereBuffer;
float2 Offset;
float4x4 CameraToWorld;
float4x4 CameraInverseProjection;
uint ReflectTimes;
float4 directionalLight;
float randSeed;

Ray PrimaryRayFromCam(float2 uv);
RayHit PathTrace(Ray ray);
void IntersectGroundPlane(Ray ray, inout RayHit hit);
void IntersectSphere(Ray ray, inout RayHit hit, uint i);
bool InterseTriangle(Ray ray, float3 vert0, float3 vert1, float3 vert2, inout float t, inout float u, inout float v);
float3 Shading(inout Ray ray, RayHit hit, uint2 idxy);
float3 HemiSpehereSampling(uint2 idxy, float3 normal, float alpha);
float3x3 ToTangentSpace(float3 normal);
Ray GenerateRay(float3 position, float3 direction);
RayHit GenerateRayHit();
float Rand(uint2 seed);
float Sdot(float3 x, float3 y, float f);
float SmoothPhongAlpha(float smoothness);

[numthreads(16, 16, 1)]
void RayTracing (uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    Result.GetDimensions(width, height);
    float2 uv = (id.xy + Offset) / float2(width, height) * 2.0 - 1.0;
    Ray ray = PrimaryRayFromCam(uv);
    float3 result = float3(0.0, 0.0, 0.0);

    for (uint i = 0; i < ReflectTimes; ++i){
        RayHit hit = PathTrace(ray);
        result += ray.energy * Shading(ray, hit, id.xy);

        if (!any(ray.energy))
            break;
    }
    Result[id.xy] = float4(result, 1.0);
}

Ray GenerateRay(float3 position, float3 direction){
    Ray ray;
    ray.pos = position;
    ray.dir = direction;
    ray.energy = float3(1.0, 1.0, 1.0);
    return ray;
}

RayHit GenerateRayHit(){
    RayHit hit;
    hit.dist = 1.#INF;
    hit.smoothness = 0.0;
    hit.pos = float3(0.0, 0.0, 0.0);
    hit.normal = float3(0.0, 0.0, 0.0);
    hit.specular = float3(0.0, 0.0, 0.0);
    hit.albedo = float3(0.0, 0.0, 0.0);
    hit.emission = float3(0.0, 0.0, 0.0);
    return hit;
}

Ray PrimaryRayFromCam(float2 uv){
    float3 pos = mul(CameraToWorld, float4(0.0, 0.0, 0.0, 1.0)).xyz;
    float3 dir = mul(CameraInverseProjection, float4(uv, 0.0, 1.0)).xyz;
    dir = mul(CameraToWorld, float4(dir, 0.0)).xyz;
    dir = normalize(dir);
    return GenerateRay(pos, dir);
}

RayHit PathTrace(Ray ray){
    RayHit hit = GenerateRayHit();
    uint sphereCount, strides;
    SphereBuffer.GetDimensions(sphereCount, strides);
    for (uint i = 0; i < sphereCount; ++i){
        IntersectSphere(ray, hit, i);
    }
    IntersectGroundPlane(ray, hit);

    // Trace single triangle
    float3 v0 = float3(-150, 0, -150);
    float3 v1 = float3(150, 0, -150);
    float3 v2 = float3(0, 150 * sqrt(2), -150);
    float t, u, v;
    if (InterseTriangle(ray, v0, v1, v2, t, u, v))
    {
        if (t > 0 && t < hit.dist)
        {
            hit.dist = t;
            hit.pos = ray.pos + t * ray.dir;
            hit.normal = normalize(cross(v1 - v0, v2 - v0));
            hit.albedo = 0.00f;
            hit.specular = 0.65f * float3(1, 0.4f, 0.2f);
            hit.smoothness = 0.9f;
            hit.emission = 0.0f;
        }
    }

    return hit;
}

void IntersectGroundPlane(Ray ray, inout RayHit hit)
{
    float t = -ray.pos.y / ray.dir.y;
    if (t > 0 && t < hit.dist)
    {
        hit.dist = t;
        hit.pos = ray.pos + t * ray.dir;
        hit.normal = float3(0.0, 1.0, 0.0);
        hit.albedo = float3(0.3, 0.3, 0.3);
        hit.specular = float3(0.4, 0.4, 0.4);
        hit.smoothness = 0.2;
        hit.emission = float3(0.04, 0.04, 0.04);
    }
}

void IntersectSphere(Ray ray, inout RayHit hit, uint index){
    Sphere sphere = SphereBuffer[index];
    float3 dist = ray.pos - sphere.pos;
    float p1 = -dot(ray.dir, dist);
    float p2 = pow(p1, 2) - dot(dist, dist) + sphere.radius * sphere.radius;
    if (p2 < 0)
        return;
    p2 = sqrt(p2);
    float t = p1 - p2 > 0 ? p1 - p2 : p1 + p2;
    if (t > 0 && t < hit.dist){
        hit.dist = t;
        hit.pos = ray.pos + t * ray.dir;
        hit.normal = normalize(hit.pos - sphere.pos);
        hit.albedo = sphere.albedo;
        hit.specular = sphere.specular;
        hit.smoothness = sphere.smoothness;
        hit.emission = sphere.emission;
    }
}

bool InterseTriangle(Ray ray, float3 vert0, float3 vert1, float3 vert2, inout float t, inout float u, inout float v){
    float3 edge1 = vert1 - vert0;
    float3 edge2 = vert2 - vert0;
    float3 s = ray.pos - vert0;
    float3 s1 = cross(ray.dir, edge2);
    float3 s2 = cross(s, edge1);
    float S1DotE1 = dot(s1, edge1);
    if (S1DotE1 < 1e-8)
        return false;
    t = dot(s2, edge2) / S1DotE1;
    u = dot(s1, s) / S1DotE1;
    if (u < 0.0 || u > 1.0)
        return false;
    v = dot(s2, ray.dir) / S1DotE1;
    if (v < 0.0 || u + v > 1.0)
        return false;

    return true;
}

float3 Shading(inout Ray ray, RayHit hit, uint2 idxy){
    if (hit.dist < 1.#INF){
        ray.pos = hit.pos + hit.normal * 0.001;
        float3 relfection = reflect(ray.dir, hit.normal);
#if _WHITE_STYLE
        ray.dir = relfection;
        ray.energy *= hit.specular;
        // shadow map generate
        Ray shadowRay = GenerateRay(hit.pos + hit.normal * 0.001, -1 * directionalLight.xyz);
        RayHit shadowHit = PathTrace(shadowRay);
        if (shadowHit.dist != 1.#INF){
            return float3(0.0, 0.0, 0.0);
        }
        // 光线和光线指向相反的方向，因此对于正面照明，点积返回 -1 而不是 1。我们需要翻转标志来弥补这一点
        return saturate(dot(hit.normal, directionalLight.xyz) * -1) * directionalLight.w * hit.albedo;
#else
        // TODO: Diffuse 目前采用的是lambert-Phong着色，随后可以修正为Disney Principle pbr
        hit.albedo = min(1 - hit.specular, hit.albedo);
        float diffuseChance = dot(hit.albedo, 1.0 / 3.0);
        float specularChance = dot(hit.specular, 1.0 / 3.0);
        float judge = Rand(idxy);

        if (judge < diffuseChance){
            // 采用漫反射
            ray.dir = HemiSpehereSampling(idxy, hit.normal, 1.0);
            ray.energy *= hit.albedo * (1.0 / diffuseChance);
        } else if (specularChance > 0 && judge < specularChance + diffuseChance){
            // 采用高光反射
            float alpha = SmoothPhongAlpha(hit.smoothness);
            ray.dir = HemiSpehereSampling(idxy, relfection, alpha);
            float f = (alpha + 2) / (alpha + 1);
            ray.energy *= hit.specular * Sdot(ray.dir, hit.normal, f) * (1.0 / specularChance);
        } else{
            // 自发光
            ray.energy = 0.0f;
        }
        return hit.emission;
#endif
    } else {
        ray.energy = float3(0.0, 0.0, 0.0);
        return Skybox.SampleLevel(samplerSkybox, ray.dir, 0).xyz;
    }
}

// 单位半球面均匀分布采样点生成原理参考http://corysimon.github.io/articles/uniformdistn-on-sphere/
// Theta表示单位角， phi表示极角, 是使用余弦功率分布将正方形映射到圆盘，以选择分布的形状和密度,产生零功率的均匀分布。
float3 HemiSpehereSampling(uint2 idxy, float3 normal, float alpha){
    float cosTheta = pow(Rand(idxy), 1.0 / (alpha + 1.0));
    float sinTheta = sqrt(saturate(1.0 - cosTheta * cosTheta));
    float phi = 2 * PI * Rand(idxy);
    float3 samplingDir = float3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);
    return mul(samplingDir, ToTangentSpace(normal));
}

float3x3 ToTangentSpace(float3 normal){
    float3 assist = float3(1.0, 0.0, 0.0);
    if (abs(normal.x) > 0.99)
        assist = float3(0.0, 0.0, 1.0);

    float3 tangent = normalize(cross(normal, assist));
    float3 binormal = normalize(cross(normal, tangent));
    return float3x3(tangent, binormal, normal);
}

float Rand(uint2 seed){
    float result = frac(sin(randSeed / 100.0 * dot(seed, float2(12.9898, 78.233))) * 43758.5453);
    randSeed += 1.0;
    return result;
}

float Sdot(float3 x, float3 y, float f)
{
    return saturate(dot(x, y) * f);
}

float SmoothPhongAlpha(float smoothness)
{
    return pow(10000.0, smoothness);
}
