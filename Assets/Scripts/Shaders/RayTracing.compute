#pragma kernel RayTracing
#pragma multi_compile_local __ _WHITE_STYLE
#pragma multi_compile_local __ _USE_OUTSIDE_MODEL

#include "Struct.compute"
#include "Shading.compute"

// Create a RenderTexture with enableRandomWrite flag and set it with cs.SetTexture
RWTexture2D<float4> Result;
TextureCube<float4> Skybox;
// 采样器名称必须和纹理名称完全一致再在前面加上sampler
SamplerState samplerSkybox;
StructuredBuffer<MeshObject> meshObjectBuffer;
StructuredBuffer<float3> verticesBuffer;
StructuredBuffer<int> indicesBuffer;
StructuredBuffer<Sphere> SphereBuffer;
float2 Offset;
float4x4 CameraToWorld;
float4x4 CameraInverseProjection;
uint ReflectTimes;
float4 directionalLight;
float3 lightColor;
float randSeed;

Ray PrimaryRayFromCam(float2 uv);
RayHit PathTrace(Ray ray);
void IntersectGroundPlane(Ray ray, inout RayHit hit);
void IntersectSphere(Ray ray, inout RayHit hit, uint i);
bool IntersectTriangle(Ray ray, float3 vert0, float3 vert1, float3 vert2, inout float t, inout float u, inout float v);
void IntersectObject(Ray ray, inout RayHit hit, MeshObject object);
float3 Shading(inout Ray ray, RayHit hit, uint2 idxy);
float3 HemiSpehereSampling(uint2 idxy, float3 normal, float alpha = 0.0);
float3 GGXSampling(uint2 idxy, float3 normal, float r2);
float3x3 ToTangentSpace(float3 normal);
Ray GenerateRay(float3 position, float3 direction);
RayHit GenerateRayHit();
float Rand(uint2 seed);

[numthreads(16, 16, 1)]
void RayTracing (uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    Result.GetDimensions(width, height);
    float2 uv = (id.xy + Offset) / float2(width, height) * 2.0 - 1.0;
    Ray ray = PrimaryRayFromCam(uv);
    float3 result = float3(0.0, 0.0, 0.0);

    for (uint i = 0; i < ReflectTimes; ++i){
        RayHit hit = PathTrace(ray);
        float isEmssion = dot(hit.emission, float3(1, 1, 1));
        if (isEmssion == 0){
            Ray shadowRay = GenerateRay(hit.pos + hit.normal * 0.001, directionalLight.xyz + HemiSpehereSampling(id.xy, hit.normal) * 0.4);
            RayHit shadowHit = PathTrace(shadowRay);
            isEmssion = dot(shadowHit.emission, float3(1, 1, 1));
            if (shadowHit.dist != 1.#INF && isEmssion == 0){
                break;
            }
        }
        result += ray.energy * Shading(ray, hit, id.xy);

        if (!any(ray.energy))
            break;
    }
    Result[id.xy] = float4(result, 1.0);
}

Ray GenerateRay(float3 position, float3 direction){
    Ray ray;
    ray.pos = position;
    ray.dir = direction;
    ray.energy = float3(1.0, 1.0, 1.0);
    return ray;
}

RayHit GenerateRayHit(){
    RayHit hit;
    hit.dist = 1.#INF;
    hit.metallic = 0.0;
    hit.roughness = 0.0;
    hit.subsurface = 0.0;
    hit.pos = float3(0.0, 0.0, 0.0);
    hit.normal = float3(0.0, 0.0, 0.0);
    hit.specular = float3(0.0, 0.0, 0.0);
    hit.albedo = float3(0.0, 0.0, 0.0);
    hit.emission = float3(0.0, 0.0, 0.0);
    return hit;
}

Ray PrimaryRayFromCam(float2 uv){
    float3 pos = mul(CameraToWorld, float4(0.0, 0.0, 0.0, 1.0)).xyz;
    float3 dir = mul(CameraInverseProjection, float4(uv, 0.0, 1.0)).xyz;
    dir = mul(CameraToWorld, float4(dir, 0.0)).xyz;
    dir = normalize(dir);
    return GenerateRay(pos, dir);
}

RayHit PathTrace(Ray ray){
    RayHit hit = GenerateRayHit();
    IntersectGroundPlane(ray, hit);
    uint meshCount, strides, i;
#if _USE_OUTSIDE_MODEL
    meshObjectBuffer.GetDimensions(meshCount, strides);
    for (i = 0; i < meshCount; ++i)
        IntersectObject(ray, hit, meshObjectBuffer[i]);
#else
    SphereBuffer.GetDimensions(meshCount, strides);
    for (i = 0; i < meshCount; ++i){
        IntersectSphere(ray, hit, i);
    }
#endif
    return hit;
}

void IntersectGroundPlane(Ray ray, inout RayHit hit)
{
    float t = -ray.pos.y / ray.dir.y;
    if (t > 0 && t < hit.dist)
    {
        hit.dist = t;
        hit.pos = ray.pos + t * ray.dir;
        hit.normal = float3(0.0, 1.0, 0.0);
        hit.albedo = float3(0.6, 0.6, 0.6);
        hit.specular = float3(0.4, 0.4, 0.4);
        hit.metallic = 0.2;
        hit.roughness = 0.5;
        hit.subsurface = 0.5;
        hit.emission = float3(0.0, 0.0, 0.0);
    }
}

void IntersectSphere(Ray ray, inout RayHit hit, uint index){
    Sphere sphere = SphereBuffer[index];
    float3 dist = ray.pos - sphere.pos;
    float p1 = -dot(ray.dir, dist);
    float p2 = pow(p1, 2) - dot(dist, dist) + sphere.radius * sphere.radius;
    if (p2 < 0)
        return;
    p2 = sqrt(p2);
    float t = p1 - p2 > 0 ? p1 - p2 : p1 + p2;
    if (t > 0 && t < hit.dist){
        hit.dist = t;
        hit.pos = ray.pos + t * ray.dir;
        hit.normal = normalize(hit.pos - sphere.pos);
        hit.albedo = sphere.albedo;
        hit.specular = sphere.specular;
        hit.metallic = sphere.metallic;
        hit.roughness = sphere.roughness;
        hit.subsurface = sphere.subsurface;
        hit.emission = sphere.emission;
    }
}

bool IntersectTriangle(Ray ray, float3 vert0, float3 vert1, float3 vert2, inout float t, inout float u, inout float v){
    float3 edge1 = vert1 - vert0;
    float3 edge2 = vert2 - vert0;
    float3 s = ray.pos - vert0;
    float3 s1 = cross(ray.dir, edge2);
    float3 s2 = cross(s, edge1);
    float S1DotE1 = dot(s1, edge1);
    if (S1DotE1 < 1e-8)
        return false;
    t = dot(s2, edge2) / S1DotE1;
    u = dot(s1, s) / S1DotE1;
    if (u < 0.0 || u > 1.0)
        return false;
    v = dot(s2, ray.dir) / S1DotE1;
    if (v < 0.0 || u + v > 1.0)
        return false;

    return true;
}

void IntersectObject(Ray ray, inout RayHit hit, MeshObject object){
    uint offset = object.indiceOffset;
    uint count = offset + object.indiceCount;
    for (uint i = offset; i < count; i += 3){
        float3 v0 = mul(object.localToWorldMatrix, float4(verticesBuffer[indicesBuffer[i]], 1)).xyz;
        float3 v1 = mul(object.localToWorldMatrix, float4(verticesBuffer[indicesBuffer[i + 1]], 1)).xyz;
        float3 v2 = mul(object.localToWorldMatrix, float4(verticesBuffer[indicesBuffer[i + 2]], 1)).xyz;
        float t, u, v;
        if (IntersectTriangle(ray, v0, v1, v2, t, u, v))
        {
            if (t > 0 && t < hit.dist)
            {
                hit.dist = t;
                hit.pos = ray.pos + t * ray.dir;
                hit.normal = normalize(cross(v1 - v0, v2 - v0));
                hit.albedo = object.albedo;
                hit.specular = object.specular;
                hit.metallic = object.metallic;
                hit.roughness = object.roughness;
                hit.subsurface = object.subsurface;
                hit.emission = object.emission;
            }
        }
    }
}

float3 Shading(inout Ray ray, RayHit hit, uint2 idxy){
    if (hit.dist < 1.#INF){
        ray.pos = hit.pos + hit.normal * 0.001;
        float3 reflection = reflect(ray.dir, hit.normal);
#if _WHITE_STYLE
        ray.dir = reflection;
        ray.energy *= hit.specular;
        // 光线和光线指向相反的方向，因此对于正面照明，点积返回 -1 而不是 1。我们需要翻转标志来弥补这一点
        return saturate(dot(hit.normal, directionalLight.xyz)) * directionalLight.w * hit.albedo;
#else
        hit.albedo = min(1 - hit.specular, hit.albedo);
        float ndotl = dot(hit.normal, directionalLight.xyz);
        float ndotv = dot(hit.normal, -ray.dir);
        float3 halfDir = normalize(directionalLight.xyz - ray.dir);
        float ndoth = dot(hit.normal, halfDir);
        float ldoth = dot(directionalLight.xyz, halfDir);
        float r2 = hit.roughness * hit.roughness;

        float diffuseChance = min(0.8, 1.0 - hit.metallic);
        float specularChance = 1 - diffuseChance;
        float judge = Rand(idxy);

        if (judge < diffuseChance){
            // 采用漫反射
            ray.dir = HemiSpehereSampling(idxy, hit.normal, 1.0);
            ray.energy *= hit.albedo * DisneyDiffuse(hit.roughness, ldoth, ndotl, ndotv, hit.subsurface) * (2.0 / diffuseChance) * (1 - hit.metallic);
        } else if (judge < specularChance){
            // 采用高光反射
            ray.dir = GGXSampling(idxy, reflection, r2);
            float3 f = lerp(hit.specular, float3(1.0, 1.0, 1.0), SchlickFresnel(ldoth));
            ray.energy *= f * SmithGGX(r2, ndotv, ndotl) * GGXShadow(r2, ndoth) * (2.0 / specularChance);
        } else{
            ray.energy = 0.0f;
        }
        ray.energy *= directionalLight.w * lightColor.xyz * max(0, ndotl);
        return hit.emission;
#endif
    } else {
        ray.energy = float3(0.0, 0.0, 0.0);
        return Skybox.SampleLevel(samplerSkybox, ray.dir, 0).xyz;
    }
}

// 单位半球面均匀分布采样点生成和半球上做重要性采样参考http://corysimon.github.io/articles/uniformdistn-on-sphere/
float3 HemiSpehereSampling(uint2 idxy, float3 normal, float alpha){
    float cosTheta = pow(Rand(idxy), 1.0 / (alpha + 1.0));
    float sinTheta = sqrt(saturate(1.0 - cosTheta * cosTheta));
    float phi = 2 * PI * Rand(idxy);
    float3 samplingDir = float3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);
    return mul(samplingDir, ToTangentSpace(normal));
}

float3 GGXSampling(uint2 idxy, float3 normal, float r2){
    float random = Rand(idxy);
    float cosTheta = sqrt((1.0 - random) / (1.0 + (r2 - 1.0f) * random));
    float sinTheta = sqrt(saturate(1.0 - cosTheta * cosTheta));
    float phi = 2 * PI * random;
    float3 samplingDir = float3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);
    return mul(samplingDir, ToTangentSpace(normal));
}

float3x3 ToTangentSpace(float3 normal){
    float3 assist = float3(1.0, 0.0, 0.0);
    if (abs(normal.x) > 0.99)
        assist = float3(0.0, 0.0, 1.0);

    float3 tangent = normalize(cross(normal, assist));
    float3 binormal = normalize(cross(normal, tangent));
    return float3x3(tangent, binormal, normal);
}

float Rand(uint2 seed){
    float result = frac(sin(randSeed / 100.0 * dot(seed, float2(12.9898, 78.233))) * 43758.5453);
    randSeed += 1.0;
    return result;
}